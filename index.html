<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Biosphere Explorer</title>
  <style>
    :root { --bg: #05070a; --accent: #00e5ff; --text: #f0f0f0; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
    #app { position: fixed; inset: 0; }
    
    /* UI OVERLAY */
    #overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.85);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; transition: opacity 0.5s ease;
    }
    h1 { font-weight: 300; letter-spacing: 6px; margin: 0 0 10px 0; font-size: 8vw; text-transform: uppercase; text-align: center;}
    h1 span { font-weight: 800; color: var(--accent); }
    p { color: #888; font-size: 14px; margin-bottom: 30px; letter-spacing: 1px; }
    
    #startBtn {
      padding: 15px 40px; font-size: 16px; font-weight: 700; letter-spacing: 2px;
      background: transparent; color: var(--accent); border: 2px solid var(--accent); 
      cursor: pointer; text-transform: uppercase; transition: all 0.2s; border-radius: 30px;
    }
    #startBtn:hover, #startBtn:active { background: var(--accent); color: #000; box-shadow: 0 0 40px var(--accent); }

    /* HUD / PROGRESS */
    #hud {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      width: 60%; pointer-events: none; opacity: 0; transition: opacity 1s;
      z-index: 50;
    }
    #progress-bg { 
      width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; 
    }
    #progress-bar { 
      width: 100%; height: 100%; background: var(--accent); box-shadow: 0 0 10px var(--accent); 
      transform-origin: left center;
      transform: scaleX(0);
      will-change: transform;
    }

    /* JOYSTICKS ZONES */
    .joystick-zone {
        position: fixed; bottom: 40px; width: 150px; height: 150px; z-index: 50;
    }
    #zone-left { left: 40px; }
    #zone-right { right: 40px; }

    /* CALIBRATION UI */
    #calibration-ui {
        position: fixed; top: 10px; right: 10px; 
        color: #00e5ff; font-family: monospace; font-size: 11px; 
        background: rgba(0,0,0,0.7); padding: 10px; border-radius: 4px;
        pointer-events: none; z-index: 40; text-align: right;
        white-space: pre;
        contain: content;
    }
    #calibration-ui strong { display: block; margin-bottom: 4px; }
    .cal-row { display: block; }

    /* LOADING INDICATOR */
    #loading-indicator {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        color: var(--accent); font-size: 12px; letter-spacing: 2px;
        z-index: 101; opacity: 0; transition: opacity 0.3s;
    }
    #loading-indicator.visible { opacity: 1; }

    /* ========================================= */
    /* ‚å®Ô∏è CONTROLS VISUALIZER */
    /* ========================================= */
    #controls-widget {
        position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
        display: flex; gap: 40px; align-items: center;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        padding: 15px 30px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.1);
        pointer-events: none;
        z-index: 60;
        transition: opacity 0.5s;
        contain: layout style;
    }

    .control-group {
        display: flex; flex-direction: column; align-items: center; gap: 8px;
    }

    .keys-container {
        display: grid;
        grid-template-columns: repeat(3, 40px);
        gap: 5px;
    }
    
    .key {
        width: 40px; height: 40px;
        border: 2px solid rgba(255,255,255,0.2);
        border-radius: 8px;
        color: rgba(255,255,255,0.5);
        display: flex; justify-content: center; align-items: center;
        font-weight: 700; font-size: 14px;
        transition: all 0.1s ease;
        will-change: transform, background-color, border-color;
    }
    
    /* Active State (When pressed) */
    .key.active {
        border-color: var(--accent);
        background: var(--accent);
        color: #000;
        box-shadow: 0 0 15px var(--accent);
        transform: translateY(2px);
    }

    /* Spacer for WASD Layout */
    .key-spacer { width: 40px; height: 40px; }

    /* Mouse Icon */
    .mouse-icon {
        width: 32px; height: 48px;
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 16px;
        position: relative;
    }
    .mouse-wheel {
        width: 4px; height: 8px; background: var(--accent);
        position: absolute; top: 8px; left: 50%; transform: translateX(-50%);
        border-radius: 2px;
    }

    .widget-label {
        font-size: 10px; letter-spacing: 2px; color: rgba(255,255,255,0.4); text-transform: uppercase;
    }

    /* Hide Controls Widget on Mobile */
    @media (max-width: 768px) {
        #controls-widget { display: none; }
        h1 { font-size: 32px; }
        #zone-left { left: 20px; bottom: 20px; }
        #zone-right { right: 20px; bottom: 20px; }
    }
  </style>

  <!-- Load Nipple.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

  <!-- Import Map -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <!-- CALIBRATION UI - Optimized with individual spans -->
  <div id="calibration-ui">
    <strong>CALIBRATION DATA</strong>
    <span class="cal-row">POS X: <span id="cal-px">0.00</span></span>
    <span class="cal-row">POS Y: <span id="cal-py">0.00</span></span>
    <span class="cal-row">POS Z: <span id="cal-pz">0.00</span></span>
    <span class="cal-row">----------------</span>
    <span class="cal-row">ROT X: <span id="cal-rx">0.00</span></span>
    <span class="cal-row">ROT Y: <span id="cal-ry">0.00</span></span>
    <span class="cal-row">ORDER: <span id="cal-order">YXZ</span></span>
    <span class="cal-row">PATH: <span id="cal-path">0.0</span>%</span>
  </div>

  <div id="app"></div>

  <div id="overlay">
    <h1>Biosphere<span>Explorer</span></h1>
    <p>MOBILE & DESKTOP READY</p>
    <button id="startBtn">ENTER</button>
  </div>

  <div id="hud">
    <div id="progress-bg"><div id="progress-bar"></div></div>
  </div>

  <!-- Loading Indicator -->
  <div id="loading-indicator">LOADING POINT CLOUD...</div>

  <!-- BEAUTIFUL CONTROLS WIDGET -->
  <div id="controls-widget">
      <!-- WASD Group -->
      <div class="control-group">
          <div class="keys-container">
              <div class="key-spacer"></div>
              <div id="ui-key-w" class="key">W</div>
              <div class="key-spacer"></div>
              
              <div id="ui-key-a" class="key">A</div>
              <div id="ui-key-s" class="key">S</div>
              <div id="ui-key-d" class="key">D</div>
          </div>
          <div class="widget-label">Move</div>
      </div>

      <!-- Divider -->
      <div style="width: 1px; height: 50px; background: rgba(255,255,255,0.1);"></div>

      <!-- Mouse Group -->
      <div class="control-group">
          <div style="height: 40px; display: flex; align-items: center;">
            <div class="mouse-icon"><div class="mouse-wheel"></div></div>
          </div>
          <div style="height: 40px; display: none;"></div> 
          <div class="widget-label">Look</div>
      </div>
  </div>

  <!-- Joystick Containers -->
  <div id="zone-left" class="joystick-zone"></div>
  <div id="zone-right" class="joystick-zone"></div>

  <script type="module">
    import * as THREE from 'three';
    import { load } from 'https://cdn.jsdelivr.net/npm/@loaders.gl/core@4.3.3/+esm';
    import { LASLoader } from 'https://cdn.jsdelivr.net/npm/@loaders.gl/las@4.3.3/+esm';

    // =========================================================================
    // üåç SETTINGS
    // =========================================================================

    const SETTINGS = {
        startPos: new THREE.Vector3(-25.72, 25.83, 0.64),
        
        walkSpeed: 2.5,  
        keyTurnSpeed: 1.5,   
        mouseSensitivity: 0.002, 
        touchTurnSpeed: 2.0, 

        fileUrl: './cloud_web.laz',
        metaUrl: './cloud_web.meta.json',
        
        // Performance settings
        curveSamples: 1000,  // Pre-sampled curve points for O(1) lookup
        uiUpdateInterval: 50, // Update calibration UI every N ms (reduces reflows)
    };

    // YOUR RECORDED PATH
    let SAVED_PATH = [
        new THREE.Vector3(24.30, -3.32, -5.97),
        new THREE.Vector3(24.44, -3.93, -6.55),
        new THREE.Vector3(23.63, -5.71, -6.65),
        new THREE.Vector3(21.51, -4.81, -6.66),
        new THREE.Vector3(20.81, -4.52, -6.66),
        new THREE.Vector3(20.22, -7.63, -6.50),
        new THREE.Vector3(19.72, -11.16, -6.46),
        new THREE.Vector3(18.81, -14.91, -7.22),
        new THREE.Vector3(18.42, -16.12, -7.21),
        new THREE.Vector3(17.27, -19.00, -7.18),
        new THREE.Vector3(18.13, -20.69, -7.16),
        new THREE.Vector3(18.09, -22.64, -7.83),
        new THREE.Vector3(18.38, -22.36, -7.44),
        new THREE.Vector3(13.64, -22.49, -6.71),
        new THREE.Vector3(9.81, -22.42, -5.84),
        new THREE.Vector3(5.20, -22.46, -5.49),
        new THREE.Vector3(4.33, -22.57, -5.96),
        new THREE.Vector3(2.98, -21.57, -4.82),
        new THREE.Vector3(1.06, -19.60, -4.44),
        new THREE.Vector3(1.20, -18.74, -4.41),
        new THREE.Vector3(1.36, -17.62, -3.43),
        new THREE.Vector3(2.89, -15.20, -2.97),
        new THREE.Vector3(3.36, -14.56, -2.75),
        new THREE.Vector3(5.14, -12.44, -2.35),
        new THREE.Vector3(7.38, -9.85, -2.06),
        new THREE.Vector3(8.70, -8.28, -1.76),
        new THREE.Vector3(8.17, -7.58, -1.63),
        new THREE.Vector3(7.39, -6.68, -1.79),
        new THREE.Vector3(6.45, -5.82, -1.63),
        new THREE.Vector3(5.68, -5.41, -1.55),
        new THREE.Vector3(4.06, -6.23, -1.70),
        new THREE.Vector3(1.54, -4.95, -1.57),
        new THREE.Vector3(-1.13, -2.91, -1.33),
        new THREE.Vector3(-1.72, -2.48, -1.74),
        new THREE.Vector3(-3.87, -0.60, -2.12),
        new THREE.Vector3(-5.35, 0.73, -2.10),
        new THREE.Vector3(-7.65, 2.79, -2.15),
        new THREE.Vector3(-6.50, 5.06, -2.24),
        new THREE.Vector3(-4.54, 9.00, -1.79),
        new THREE.Vector3(-4.09, 9.65, -2.72),
        new THREE.Vector3(-3.05, 12.21, -2.43),
        new THREE.Vector3(-2.16, 14.04, -2.22),
        new THREE.Vector3(-3.77, 15.26, -2.51),
        new THREE.Vector3(-6.84, 16.57, -2.36),
        new THREE.Vector3(-7.97, 16.62, -1.97),
        new THREE.Vector3(-10.63, 16.76, -1.95),
        new THREE.Vector3(-12.76, 14.49, -2.21),
        new THREE.Vector3(-14.00, 13.36, -1.74),
        new THREE.Vector3(-16.88, 10.71, -1.20),
        new THREE.Vector3(-18.65, 11.89, -1.03),
        new THREE.Vector3(-21.00, 13.71, -0.58),
        new THREE.Vector3(-22.38, 14.82, -0.45),
        new THREE.Vector3(-24.24, 16.36, 0.61),
        new THREE.Vector3(-25.74, 17.57, 1.02),
        new THREE.Vector3(-26.48, 18.34, 1.11),
        new THREE.Vector3(-26.47, 19.41, 1.23),
        new THREE.Vector3(-26.04, 23.36, 1.16),
        new THREE.Vector3(-25.79, 24.83, 0.86),
        new THREE.Vector3(-25.72, 25.83, 0.64),
    ];

    // Auto-reverse path if needed
    const startDist = SETTINGS.startPos.distanceTo(SAVED_PATH[0]);
    const endDist = SETTINGS.startPos.distanceTo(SAVED_PATH[SAVED_PATH.length - 1]);
    if (endDist < startDist) SAVED_PATH.reverse();

    // =========================================================================
    // üéØ STATE VARIABLES
    // =========================================================================
    
    // Movement flags (using bitfield for faster checks)
    let moveFlags = 0;
    const MOVE_FORWARD = 1;
    const MOVE_BACKWARD = 2;
    const TURN_LEFT = 4;
    const TURN_RIGHT = 8;
    
    let joyMove = 0, joyLookX = 0, joyLookY = 0;
    
    let railProgress = 0; 
    let railCurve = null;
    let totalRailLength = 0;
    let invRailLength = 0; // Pre-computed 1/length for faster division
    let prevTime = 0;
    let lastUIUpdate = 0;
    const centerOffset = new THREE.Vector3();
    const WORLD_UP = new THREE.Vector3(0, 0, 1);
    
    // Pre-sampled curve points for O(1) lookup
    let curvePointsCache = null;
    
    // Reusable objects (avoid GC in animation loop)
    const _tempVec3 = new THREE.Vector3();
    const _targetPos = new THREE.Vector3();

    // =========================================================================
    // üñ•Ô∏è DOM ELEMENT CACHE
    // =========================================================================
    
    const DOM = {
        app: document.getElementById('app'),
        overlay: document.getElementById('overlay'),
        startBtn: document.getElementById('startBtn'),
        hud: document.getElementById('hud'),
        progressBar: document.getElementById('progress-bar'),
        loadingIndicator: document.getElementById('loading-indicator'),
        // Calibration UI elements (individual for targeted updates)
        calPx: document.getElementById('cal-px'),
        calPy: document.getElementById('cal-py'),
        calPz: document.getElementById('cal-pz'),
        calRx: document.getElementById('cal-rx'),
        calRy: document.getElementById('cal-ry'),
        calOrder: document.getElementById('cal-order'),
        calPath: document.getElementById('cal-path'),
        // Key UI elements
        keys: {
            'KeyW': document.getElementById('ui-key-w'),
            'KeyA': document.getElementById('ui-key-a'),
            'KeyS': document.getElementById('ui-key-s'),
            'KeyD': document.getElementById('ui-key-d')
        }
    };
    
    // Map Arrows to same keys for visual feedback
    const KEY_MAP = {
        'ArrowUp': 'KeyW', 
        'ArrowLeft': 'KeyA', 
        'ArrowDown': 'KeyS', 
        'ArrowRight': 'KeyD'
    };

    // =========================================================================
    // üé¨ SCENE SETUP
    // =========================================================================
    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070a);
    scene.fog = new THREE.FogExp2(0x05070a, 0.015);

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
    
    // Optimized renderer settings
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        powerPreference: "high-performance",
        stencil: false,  // Not needed, saves memory
        depth: true,
        alpha: false,    // Opaque background, no alpha needed
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.sortObjects = false; // Points don't need sorting
    DOM.app.appendChild(renderer.domElement);

    // =========================================================================
    // üïπÔ∏è JOYSTICK SETUP
    // =========================================================================
    
    const mgrLeft = nipplejs.create({
        zone: document.getElementById('zone-left'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: '#00e5ff'
    });
    
    const mgrRight = nipplejs.create({
        zone: document.getElementById('zone-right'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: '#00e5ff'
    });

    mgrLeft.on('move', (evt, data) => { 
        joyMove = Math.sin(data.angle.radian) * (data.distance * 0.02); // Pre-multiply instead of divide
    });
    mgrLeft.on('end', () => { joyMove = 0; });

    mgrRight.on('move', (evt, data) => {
        const dist = data.distance * 0.02;
        joyLookX = Math.cos(data.angle.radian) * dist;
        joyLookY = Math.sin(data.angle.radian) * dist;
    });
    mgrRight.on('end', () => { joyLookX = 0; joyLookY = 0; });

    // =========================================================================
    // üõ§Ô∏è PATH/CURVE SETUP
    // =========================================================================
    
    function initCurve() {
        railCurve = new THREE.CatmullRomCurve3(SAVED_PATH);
        railCurve.curveType = 'centripetal';
        railCurve.tension = 0.5;
        totalRailLength = railCurve.getLength();
        invRailLength = 1 / totalRailLength; // Pre-compute inverse for faster multiplication
        
        // Pre-sample curve points for O(1) lookup instead of O(n) getPointAt
        const samples = SETTINGS.curveSamples;
        curvePointsCache = new Float32Array(samples * 3);
        for (let i = 0; i < samples; i++) {
            const t = i / (samples - 1);
            const point = railCurve.getPointAt(t);
            const idx = i * 3;
            curvePointsCache[idx] = point.x;
            curvePointsCache[idx + 1] = point.y;
            curvePointsCache[idx + 2] = point.z;
        }
    }
    
    // Fast curve point lookup using pre-sampled cache
    function getCurvePointFast(t, target) {
        const samples = SETTINGS.curveSamples;
        const idx = Math.min(Math.floor(t * (samples - 1)), samples - 2);
        const localT = (t * (samples - 1)) - idx;
        
        const i0 = idx * 3;
        const i1 = (idx + 1) * 3;
        
        // Linear interpolation between cached samples
        target.x = curvePointsCache[i0] + (curvePointsCache[i1] - curvePointsCache[i0]) * localT;
        target.y = curvePointsCache[i0 + 1] + (curvePointsCache[i1 + 1] - curvePointsCache[i0 + 1]) * localT;
        target.z = curvePointsCache[i0 + 2] + (curvePointsCache[i1 + 2] - curvePointsCache[i0 + 2]) * localT;
        
        return target;
    }
    
    initCurve();

    // Init Camera
    getCurvePointFast(0, _targetPos);
    camera.position.copy(_targetPos);
    camera.rotation.order = 'YXZ';
    camera.rotation.set(-1.49, 3.13, 0);

    // =========================================================================
    // üñ±Ô∏è CONTROLS & EVENT HANDLERS
    // =========================================================================
    
    // Pointer lock state cache
    let isPointerLocked = false;
    
    DOM.startBtn.addEventListener('click', () => {
        document.body.requestPointerLock();
        DOM.overlay.style.opacity = '0';
        setTimeout(() => { DOM.overlay.style.display = 'none'; }, 500);
        DOM.hud.style.opacity = '1';
    }, { passive: true });

    document.addEventListener('pointerlockchange', () => {
        isPointerLocked = document.pointerLockElement === document.body;
    }, { passive: true });

    document.addEventListener('mousemove', (event) => {
        if (!isPointerLocked) return;
        camera.rotateOnWorldAxis(WORLD_UP, -event.movementX * SETTINGS.mouseSensitivity);
        camera.rotateX(-event.movementY * SETTINGS.mouseSensitivity);
    }, { passive: true });

    // Optimized key handler
    function handleKey(code, active) {
        switch (code) {
            case 'KeyW': case 'ArrowUp':
                moveFlags = active ? (moveFlags | MOVE_FORWARD) : (moveFlags & ~MOVE_FORWARD);
                break;
            case 'KeyS': case 'ArrowDown':
                moveFlags = active ? (moveFlags | MOVE_BACKWARD) : (moveFlags & ~MOVE_BACKWARD);
                break;
            case 'KeyA': case 'ArrowLeft':
                moveFlags = active ? (moveFlags | TURN_LEFT) : (moveFlags & ~TURN_LEFT);
                break;
            case 'KeyD': case 'ArrowRight':
                moveFlags = active ? (moveFlags | TURN_RIGHT) : (moveFlags & ~TURN_RIGHT);
                break;
        }
        
        // Update visual feedback
        let mappedCode = KEY_MAP[code] || code;
        const keyEl = DOM.keys[mappedCode];
        if (keyEl) {
            if (active) {
                keyEl.classList.add('active');
            } else {
                keyEl.classList.remove('active');
            }
        }
    }

    document.addEventListener('keydown', (e) => {
        if (!e.repeat) handleKey(e.code, true);
    }, { passive: true });
    
    document.addEventListener('keyup', (e) => {
        handleKey(e.code, false);
    }, { passive: true });

    // Debounced resize handler
    let resizeTimeout = null;
    function handleResize() {
        if (resizeTimeout) return;
        resizeTimeout = setTimeout(() => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            resizeTimeout = null;
        }, 100);
    }
    window.addEventListener('resize', handleResize, { passive: true });

    // =========================================================================
    // üì¶ POINT CLOUD LOADER
    // =========================================================================
    
    async function init() {
        DOM.loadingIndicator.classList.add('visible');
        
        try {
            // Try to load metadata
            try {
                const mRes = await fetch(SETTINGS.metaUrl);
                const meta = await mRes.json();
                if (meta.origin) {
                    centerOffset.set(meta.origin[0], meta.origin[1], meta.origin[2]);
                }
            } catch (e) {
                // Metadata optional, continue without it
            }

            const data = await load(SETTINGS.fileUrl, LASLoader);
            const posAttr = data.attributes['POSITION']?.value || data.attributes['POSITION0']?.value;
            const colAttr = data.attributes['COLOR_0']?.value || data.attributes['RGB']?.value;
            const intAttr = data.attributes['intensity']?.value;

            const numPoints = posAttr.length / 3;
            const positions = new Float32Array(posAttr.length);
            
            // Batch position processing
            const ox = centerOffset.x, oy = centerOffset.y, oz = centerOffset.z;
            for (let i = 0; i < posAttr.length; i += 3) {
                positions[i] = posAttr[i] - ox;
                positions[i + 1] = posAttr[i + 1] - oy;
                positions[i + 2] = posAttr[i + 2] - oz;
            }
            
            // Process colors
            let colors = null;
            if (colAttr) {
                colors = new Float32Array(posAttr.length);
                const isUint8 = colAttr instanceof Uint8Array;
                const isUint16 = colAttr instanceof Uint16Array;
                const invMaxVal = isUint8 ? (1 / 255) : isUint16 ? (1 / 65535) : 1;
                const stride = (colAttr.length === posAttr.length) ? 3 : 4;
                
                for (let i = 0, j = 0; i < colors.length; i += 3, j += stride) {
                    colors[i] = colAttr[j] * invMaxVal;
                    colors[i + 1] = colAttr[j + 1] * invMaxVal;
                    colors[i + 2] = colAttr[j + 2] * invMaxVal;
                }
            } else if (intAttr) {
                colors = new Float32Array(posAttr.length);
                const invMax = 5 / 65535;
                for (let i = 0; i < posAttr.length; i += 3) {
                    const v = Math.min(intAttr[i / 3] * invMax, 1);
                    colors[i] = v;
                    colors[i + 1] = v;
                    colors[i + 2] = v;
                }
            }

            // Create geometry with optimizations
            const geometry = new THREE.BufferGeometry();
            
            const positionAttribute = new THREE.BufferAttribute(positions, 3);
            positionAttribute.setUsage(THREE.StaticDrawUsage); // Hint: won't change
            geometry.setAttribute('position', positionAttribute);
            
            if (colors) {
                const colorAttribute = new THREE.BufferAttribute(colors, 3);
                colorAttribute.setUsage(THREE.StaticDrawUsage);
                geometry.setAttribute('color', colorAttribute);
            }
            
            // Compute bounds for frustum culling
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();

            // Optimized material
            const material = new THREE.PointsMaterial({ 
                size: 0.0275, 
                vertexColors: !!colors, 
                color: 0xffffff,
                fog: true,
                sizeAttenuation: true,
            });

            const points = new THREE.Points(geometry, material);
            points.frustumCulled = true; // Enable frustum culling
            scene.add(points);
            
            // Clear loading indicator
            DOM.loadingIndicator.classList.remove('visible');
            
            console.log(`Loaded ${numPoints.toLocaleString()} points`);

        } catch (err) { 
            console.error('Failed to load point cloud:', err);
            DOM.loadingIndicator.textContent = 'LOAD ERROR';
        }
    }

    // =========================================================================
    // üîÑ ANIMATION LOOP
    // =========================================================================
    
    // Cached values for UI update throttling
    let cachedProgress = -1;
    
    function animate(time) {
        requestAnimationFrame(animate);
        
        // Delta time calculation
        if (prevTime === 0) prevTime = time;
        const delta = Math.min((time - prevTime) * 0.001, 0.1); // Cap delta to prevent huge jumps
        prevTime = time;

        // 1. POSITION (Rail movement)
        let speed = 0;
        if (moveFlags & MOVE_FORWARD) speed += SETTINGS.walkSpeed;
        if (moveFlags & MOVE_BACKWARD) speed -= SETTINGS.walkSpeed;
        speed += joyMove * SETTINGS.walkSpeed;

        if (speed !== 0) {
            const progressStep = speed * delta * invRailLength;
            railProgress += progressStep;
            
            // Clamp with branchless min/max
            railProgress = railProgress < 0 ? 0 : railProgress > 1 ? 1 : railProgress;
        }

        // Use fast cached curve lookup
        getCurvePointFast(railProgress, _targetPos);
        camera.position.copy(_targetPos);
        
        // 2. ROTATION (Keys/Joystick Yaw + Pitch)
        let yawAmount = 0;
        if (moveFlags & TURN_LEFT) yawAmount += SETTINGS.keyTurnSpeed * delta;
        if (moveFlags & TURN_RIGHT) yawAmount -= SETTINGS.keyTurnSpeed * delta;
        yawAmount -= joyLookX * SETTINGS.touchTurnSpeed * delta;

        if (yawAmount !== 0) {
            camera.rotateOnWorldAxis(WORLD_UP, yawAmount);
        }

        const pitchAmount = joyLookY * SETTINGS.touchTurnSpeed * delta;
        if (pitchAmount !== 0) {
            camera.rotateX(pitchAmount);
        }

        // 3. UI UPDATES (Throttled)
        // Progress bar - GPU accelerated transform
        if (railProgress !== cachedProgress) {
            DOM.progressBar.style.transform = `scaleX(${railProgress})`;
            cachedProgress = railProgress;
        }
        
        // Calibration UI - throttled to reduce reflows
        if (time - lastUIUpdate > SETTINGS.uiUpdateInterval) {
            lastUIUpdate = time;
            DOM.calPx.textContent = camera.position.x.toFixed(2);
            DOM.calPy.textContent = camera.position.y.toFixed(2);
            DOM.calPz.textContent = camera.position.z.toFixed(2);
            DOM.calRx.textContent = camera.rotation.x.toFixed(2);
            DOM.calRy.textContent = camera.rotation.y.toFixed(2);
            DOM.calPath.textContent = (railProgress * 100).toFixed(1);
        }

        // 4. RENDER
        renderer.render(scene, camera);
    }

    // =========================================================================
    // üöÄ INITIALIZATION
    // =========================================================================
    
    init();
    requestAnimationFrame(animate);

  </script>
</body>
</html>