<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Biosphere Explorer</title>
  <style>
    :root { --bg: #05070a; --accent: #00e5ff; --text: #f0f0f0; }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', sans-serif; overflow: hidden; touch-action: none; }
    #app { position: fixed; inset: 0; }
    
    /* OVERLAY */
    #overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.9);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; transition: opacity 0.5s ease;
    }
    h1 { font-weight: 300; letter-spacing: 4px; margin: 0 0 20px 0; font-size: 8vw; text-transform: uppercase; text-align: center; }
    h1 span { font-weight: 800; color: var(--accent); }
    
    #startBtn {
      padding: 15px 50px; font-size: 16px; font-weight: 700; letter-spacing: 2px;
      background: transparent; color: var(--accent); border: 2px solid var(--accent); 
      cursor: pointer; text-transform: uppercase; border-radius: 30px; display: none;
    }
    
    /* LOADING BAR */
    #loading-container { width: 200px; text-align: center; }
    #loading-text { color: #888; margin-bottom: 10px; font-size: 11px; font-family: monospace; letter-spacing: 1px;}
    #load-bar-bg { width: 100%; height: 4px; background: #333; border-radius: 2px; overflow: hidden; }
    #load-bar-fill { width: 0%; height: 100%; background: var(--accent); transition: width 0.2s; }

    /* HUD */
    #hud {
      position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
      width: 60%; pointer-events: none; opacity: 0; transition: opacity 1s; z-index: 50;
    }
    #progress-bg { width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; overflow: hidden; }
    #progress-bar { width: 0%; height: 100%; background: var(--accent); box-shadow: 0 0 10px var(--accent); }

    /* JOYSTICKS */
    .joystick-zone { position: fixed; bottom: 40px; width: 150px; height: 150px; z-index: 50; }
    #zone-left { left: 20px; }
    #zone-right { right: 20px; }
    
    /* HINT */
    #desktop-hint {
        position: fixed; bottom: 20px; width: 100%; text-align: center; color: #666; font-size: 10px; pointer-events: none;
    }
    @media (max-width: 768px) { #desktop-hint { display: none; } }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>

<body>
  <div id="app"></div>

  <div id="overlay">
    <h1>Biosphere<span>Explorer</span></h1>
    
    <div id="loading-container">
        <div id="loading-text">CONNECTING...</div>
        <div id="load-bar-bg"><div id="load-bar-fill"></div></div>
    </div>

    <button id="startBtn">ENTER</button>
  </div>

  <div id="hud">
    <div id="progress-bg"><div id="progress-bar"></div></div>
  </div>

  <div id="desktop-hint">WASD to Move ‚Ä¢ ARROWS to Look</div>

  <div id="zone-left" class="joystick-zone"></div>
  <div id="zone-right" class="joystick-zone"></div>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { load } from 'https://cdn.jsdelivr.net/npm/@loaders.gl/core@4.3.3/+esm';
    import { LASLoader } from 'https://cdn.jsdelivr.net/npm/@loaders.gl/las@4.3.3/+esm';

    // üïµÔ∏è DETECT MOBILE
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    const SETTINGS = {
        startPos: new THREE.Vector3(-25.72, 25.83, 0.64),
        startLookAt: new THREE.Vector3(-24.83, 35.57, -1.45),
        walkSpeed: 2.5,  
        keyTurnSpeed: 1.5,
        touchTurnSpeed: 2.0,
        
        // üöÄ OPTIMIZATION SETTINGS
        pointSize: isMobile ? 0.20 : 0.1,    // Bigger points on mobile
        skipPoints: isMobile ? 3 : 1,        // Skip 2 out of 3 points on mobile to save RAM
        pixelRatio: isMobile ? 1.0 : 1.5,    // Cap resolution on mobile
        
        fileUrl: './cloud_web.laz',
        metaUrl: './cloud_web.meta.json'
    };

    let SAVED_PATH = [
        new THREE.Vector3(24.30, -3.32, -5.97),
        new THREE.Vector3(24.44, -3.93, -6.55),
        new THREE.Vector3(23.63, -5.71, -6.65),
        new THREE.Vector3(21.51, -4.81, -6.66),
        new THREE.Vector3(20.81, -4.52, -6.66),
        new THREE.Vector3(20.22, -7.63, -6.50),
        new THREE.Vector3(19.72, -11.16, -6.46),
        new THREE.Vector3(18.81, -14.91, -7.22),
        new THREE.Vector3(18.42, -16.12, -7.21),
        new THREE.Vector3(17.27, -19.00, -7.18),
        new THREE.Vector3(18.13, -20.69, -7.16),
        new THREE.Vector3(18.09, -22.64, -7.83),
        new THREE.Vector3(18.38, -22.36, -7.44),
        new THREE.Vector3(13.64, -22.49, -6.71),
        new THREE.Vector3(9.81, -22.42, -5.84),
        new THREE.Vector3(5.20, -22.46, -5.49),
        new THREE.Vector3(4.33, -22.57, -5.96),
        new THREE.Vector3(2.98, -21.57, -4.82),
        new THREE.Vector3(1.06, -19.60, -4.44),
        new THREE.Vector3(1.20, -18.74, -4.41),
        new THREE.Vector3(1.36, -17.62, -3.43),
        new THREE.Vector3(2.89, -15.20, -2.97),
        new THREE.Vector3(3.36, -14.56, -2.75),
        new THREE.Vector3(5.14, -12.44, -2.35),
        new THREE.Vector3(7.38, -9.85, -2.06),
        new THREE.Vector3(8.70, -8.28, -1.76),
        new THREE.Vector3(8.17, -7.58, -1.63),
        new THREE.Vector3(7.39, -6.68, -1.79),
        new THREE.Vector3(6.45, -5.82, -1.63),
        new THREE.Vector3(5.68, -5.41, -1.55),
        new THREE.Vector3(4.06, -6.23, -1.70),
        new THREE.Vector3(1.54, -4.95, -1.57),
        new THREE.Vector3(-1.13, -2.91, -1.33),
        new THREE.Vector3(-1.72, -2.48, -1.74),
        new THREE.Vector3(-3.87, -0.60, -2.12),
        new THREE.Vector3(-5.35, 0.73, -2.10),
        new THREE.Vector3(-7.65, 2.79, -2.15),
        new THREE.Vector3(-6.50, 5.06, -2.24),
        new THREE.Vector3(-4.54, 9.00, -1.79),
        new THREE.Vector3(-4.09, 9.65, -2.72),
        new THREE.Vector3(-3.05, 12.21, -2.43),
        new THREE.Vector3(-2.16, 14.04, -2.22),
        new THREE.Vector3(-3.77, 15.26, -2.51),
        new THREE.Vector3(-6.84, 16.57, -2.36),
        new THREE.Vector3(-7.97, 16.62, -1.97),
        new THREE.Vector3(-10.63, 16.76, -1.95),
        new THREE.Vector3(-12.76, 14.49, -2.21),
        new THREE.Vector3(-14.00, 13.36, -1.74),
        new THREE.Vector3(-16.88, 10.71, -1.20),
        new THREE.Vector3(-18.65, 11.89, -1.03),
        new THREE.Vector3(-21.00, 13.71, -0.58),
        new THREE.Vector3(-22.38, 14.82, -0.45),
        new THREE.Vector3(-24.24, 16.36, 0.61),
        new THREE.Vector3(-25.74, 17.57, 1.02),
        new THREE.Vector3(-26.48, 18.34, 1.11),
        new THREE.Vector3(-26.47, 19.41, 1.23),
        new THREE.Vector3(-26.04, 23.36, 1.16),
        new THREE.Vector3(-25.79, 24.83, 0.86),
        new THREE.Vector3(-25.72, 25.83, 0.64),
    ];

    const startDist = SETTINGS.startPos.distanceTo(SAVED_PATH[0]);
    const endDist = SETTINGS.startPos.distanceTo(SAVED_PATH[SAVED_PATH.length-1]);
    if(endDist < startDist) SAVED_PATH.reverse();

    let moveF=false, moveB=false, turnL=false, turnR=false;
    let joyMove=0, joyLookX=0, joyLookY=0;
    let railProgress=0, railCurve=null, totalRailLength=0;
    let prevTime=performance.now();
    let centerOffset=new THREE.Vector3();

    const uiBar=document.getElementById('progress-bar');
    const hud=document.getElementById('hud');
    const loadText=document.getElementById('loading-text');
    const loadFill=document.getElementById('load-bar-fill');
    const loadContainer=document.getElementById('loading-container');
    const startBtn=document.getElementById('startBtn');
    const overlay=document.getElementById('overlay');

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x05070a);
    scene.fog = new THREE.FogExp2(0x05070a, 0.015); 

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, SETTINGS.pixelRatio));
    document.getElementById('app').appendChild(renderer.domElement);

    const controls = new PointerLockControls(camera, document.body);

    const mgrLeft = nipplejs.create({ zone: document.getElementById('zone-left'), mode: 'static', position: { left: '50%', top: '50%' }, color: '#00e5ff' });
    const mgrRight = nipplejs.create({ zone: document.getElementById('zone-right'), mode: 'static', position: { left: '50%', top: '50%' }, color: '#00e5ff' });

    mgrLeft.on('move', (evt, data) => { joyMove = Math.sin(data.angle.radian) * (data.distance / 50); });
    mgrLeft.on('end', () => { joyMove = 0; });
    mgrRight.on('move', (evt, data) => { joyLookX = Math.cos(data.angle.radian) * (data.distance / 50); joyLookY = Math.sin(data.angle.radian) * (data.distance / 50); });
    mgrRight.on('end', () => { joyLookX = 0; joyLookY = 0; });

    startBtn.addEventListener('click', () => {
        try { if(!isMobile) controls.lock(); } catch(e) {}
        overlay.style.opacity = '0';
        setTimeout(() => overlay.style.display = 'none', 500);
        hud.style.opacity = '1';
    });

    railCurve = new THREE.CatmullRomCurve3(SAVED_PATH);
    railCurve.curveType = 'centripetal'; 
    railCurve.tension = 0.5;
    totalRailLength = railCurve.getLength();
    camera.position.copy(railCurve.getPointAt(0));
    camera.lookAt(SETTINGS.startLookAt);

    const onKey = (e, active) => {
        switch(e.code) {
            case 'KeyW': case 'ArrowUp': moveF = active; break;
            case 'KeyS': case 'ArrowDown': moveB = active; break;
            case 'KeyA': case 'ArrowLeft': turnL = active; break;
            case 'KeyD': case 'ArrowRight': turnR = active; break;
        }
    };
    document.addEventListener('keydown', (e) => onKey(e, true));
    document.addEventListener('keyup', (e) => onKey(e, false));

    async function init() {
        try {
            try {
                const mRes = await fetch(SETTINGS.metaUrl);
                const meta = await mRes.json();
                if(meta.origin) centerOffset.set(meta.origin[0], meta.origin[1], meta.origin[2]);
            } catch(e){}

            // FETCH WITH PROGRESS
            const response = await fetch(SETTINGS.fileUrl);
            if (!response.ok) throw new Error("File not found");
            const reader = response.body.getReader();
            const contentLength = +response.headers.get('Content-Length');
            let receivedLength = 0;
            let chunks = [];
            while(true) {
                const {done, value} = await reader.read();
                if (done) break;
                chunks.push(value);
                receivedLength += value.length;
                if(contentLength) {
                    const pct = Math.round((receivedLength/contentLength)*100);
                    loadFill.style.width = pct + "%";
                    loadText.innerText = `DOWNLOADING ${pct}%`;
                }
            }
            let chunksAll = new Uint8Array(receivedLength);
            let position = 0;
            for(let chunk of chunks) { chunksAll.set(chunk, position); position += chunk.length; }

            loadText.innerText = "PROCESSING...";

            const data = await new LASLoader().parse(chunksAll.buffer);
            const posAttr = data.attributes['POSITION']?.value || data.attributes['POSITION0']?.value;
            const colAttr = data.attributes['COLOR_0']?.value || data.attributes['RGB']?.value;
            const intAttr = data.attributes['intensity']?.value;

            // OPTIMIZATION: DECIMATION
            // Calculate how many points we will actually render based on skipFactor
            const skip = SETTINGS.skipPoints;
            const totalPoints = posAttr.length / 3;
            const newCount = Math.floor(totalPoints / skip);
            
            const positions = new Float32Array(newCount * 3);
            let colors = colAttr || intAttr ? new Float32Array(newCount * 3) : null;

            let j = 0; // Index for new arrays
            
            // Loop through original points, skipping based on setting
            for(let i=0; i<totalPoints; i += skip) {
                const srcIndex = i * 3;
                
                positions[j]   = posAttr[srcIndex] - centerOffset.x;
                positions[j+1] = posAttr[srcIndex+1] - centerOffset.y;
                positions[j+2] = posAttr[srcIndex+2] - centerOffset.z;

                if(colors) {
                    if(colAttr) {
                        // Color handling
                        const maxVal = (colAttr instanceof Uint8Array) ? 255 : (colAttr instanceof Uint16Array) ? 65535 : 1;
                        const stride = (colAttr.length === posAttr.length) ? 3 : 4;
                        const colIndex = i * stride;
                        colors[j]   = colAttr[colIndex] / maxVal;
                        colors[j+1] = colAttr[colIndex+1] / maxVal;
                        colors[j+2] = colAttr[colIndex+2] / maxVal;
                    } else if (intAttr) {
                        // Intensity handling
                        const v = Math.min(intAttr[i]/65535*5, 1);
                        colors[j] = v; colors[j+1] = v; colors[j+2] = v;
                    }
                }
                j += 3;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            if(colors) geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.computeBoundingBox();

            const material = new THREE.PointsMaterial({ 
                size: SETTINGS.pointSize, 
                vertexColors: !!colors, 
                color: 0xffffff,
            });

            scene.add(new THREE.Points(geometry, material));

            loadContainer.style.display = 'none';
            startBtn.style.display = 'block';

        } catch(err) {
            loadText.innerText = "ERROR";
            loadText.style.color = "red";
            console.error(err);
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();
        const delta = (time - prevTime) / 1000;
        prevTime = time;

        let speed = 0;
        if (moveF) speed += SETTINGS.walkSpeed;
        if (moveB) speed -= SETTINGS.walkSpeed;
        speed += joyMove * SETTINGS.walkSpeed;

        const progressStep = (speed * delta) / totalRailLength;
        railProgress += progressStep;
        railProgress = Math.max(0, Math.min(1, railProgress));

        const targetPos = railCurve.getPointAt(railProgress);
        camera.position.copy(targetPos);
        
        const camObj = controls.getObject();
        if (turnL) camObj.rotation.y += SETTINGS.keyTurnSpeed * delta;
        if (turnR) camObj.rotation.y -= SETTINGS.keyTurnSpeed * delta;
        camObj.rotation.y -= joyLookX * SETTINGS.touchTurnSpeed * delta; 
        camObj.rotation.x += joyLookY * SETTINGS.touchTurnSpeed * delta;
        camObj.rotation.x = Math.max(-1.5, Math.min(1.5, camObj.rotation.x));

        uiBar.style.width = (railProgress * 100) + '%';
        renderer.render(scene, camera);
    }

    init();
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>